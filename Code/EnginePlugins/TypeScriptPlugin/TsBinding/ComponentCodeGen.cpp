#include <TypeScriptPluginPCH.h>

#include <Foundation/IO/FileSystem/FileReader.h>
#include <Foundation/IO/FileSystem/FileWriter.h>
#include <Foundation/IO/OSFile.h>
#include <TypeScriptPlugin/Components/TypeScriptComponent.h>
#include <TypeScriptPlugin/TsBinding/TsBinding.h>

ezResult ezTypeScriptBinding::SetupProjectCode()
{
  ezStringBuilder sAbsSrcFolder;
  EZ_SUCCEED_OR_RETURN(ezFileSystem::ResolvePath(":plugins/TypeScript", &sAbsSrcFolder, nullptr));

  ezStringBuilder sAbsDstFolder;
  EZ_SUCCEED_OR_RETURN(ezFileSystem::ResolvePath(":project/TypeScript", &sAbsDstFolder, nullptr));

#if (EZ_ENABLED(EZ_SUPPORTS_FILE_ITERATORS) && EZ_ENABLED(EZ_SUPPORTS_FILE_STATS))
  EZ_SUCCEED_OR_RETURN(ezOSFile::CopyFolder(sAbsSrcFolder, sAbsDstFolder));
#endif

  RemoveAutoGeneratedCode(":project/TypeScript/ez.ts");

  GenerateComponentsFile(":project/TypeScript/ez/AllComponents.ts");
  InjectComponentImportExport(":project/TypeScript/ez.ts", "./ez/AllComponents");

  GenerateMessagesFile(":project/TypeScript/ez/AllMessages.ts");
  InjectMessageImportExport(":project/TypeScript/ez.ts", "./ez/AllMessages");

  GenerateEnumsFile(":project/TypeScript/ez/AllEnums.ts", s_RequiredEnums);
  GenerateEnumsFile(":project/TypeScript/ez/AllFlags.ts", s_RequiredFlags);

  InjectEnumImportExport(":project/TypeScript/ez.ts", "./ez/AllEnums");
  InjectFlagsImportExport(":project/TypeScript/ez.ts", "./ez/AllFlags");

  return EZ_SUCCESS;
}

void ezTypeScriptBinding::GetTsName(const ezRTTI* pRtti, ezStringBuilder& out_sName)
{
  out_sName = pRtti->GetTypeName();
  out_sName.TrimWordStart("ez");
}

void ezTypeScriptBinding::GenerateComponentCode(ezStringBuilder& out_Code, const ezRTTI* pRtti)
{
  ezStringBuilder sComponentType, sParentType;
  GetTsName(pRtti, sComponentType);

  GetTsName(pRtti->GetParentType(), sParentType);

  out_Code.AppendFormat("export class {0} extends {1}\n", sComponentType, sParentType);
  out_Code.Append("{\n");
  out_Code.AppendFormat("  public static GetTypeNameHash(): number { return {}; }\n", pRtti->GetTypeNameHash());
  GenerateExposedFunctionsCode(out_Code, pRtti);
  GeneratePropertiesCode(out_Code, pRtti);
  out_Code.Append("}\n\n");
}

static void CreateComponentTypeList(ezSet<const ezRTTI*>& found, ezDynamicArray<const ezRTTI*>& sorted, const ezRTTI* pRtti)
{
  if (found.Contains(pRtti))
    return;

  if (!pRtti->IsDerivedFrom<ezComponent>())
    return;

  if (pRtti == ezGetStaticRTTI<ezComponent>() || pRtti == ezGetStaticRTTI<ezTypeScriptComponent>())
    return;

  found.Insert(pRtti);
  CreateComponentTypeList(found, sorted, pRtti->GetParentType());

  sorted.PushBack(pRtti);
}

void ezTypeScriptBinding::GenerateAllComponentsCode(ezStringBuilder& out_Code)
{
  ezSet<const ezRTTI*> found;
  ezDynamicArray<const ezRTTI*> sorted;
  sorted.Reserve(100);

  for (auto pRtti = ezRTTI::GetFirstInstance(); pRtti != nullptr; pRtti = pRtti->GetNextInstance())
  {
    CreateComponentTypeList(found, sorted, pRtti);
  }

  for (auto pRtti : sorted)
  {
    GenerateComponentCode(out_Code, pRtti);
  }
}

void ezTypeScriptBinding::GenerateComponentsFile(const char* szFile)
{
  ezStringBuilder sFileContent;

  sFileContent =
    R"(
import __GameObject = require("./GameObject")
export import GameObject = __GameObject.GameObject;

import __Component = require("./Component")
export import Component = __Component.Component;

import __Vec2 = require("./Vec2")
export import Vec2 = __Vec2.Vec2;

import __Vec3 = require("./Vec3")
export import Vec3 = __Vec3.Vec3;

import __Mat3 = require("./Mat3")
export import Mat3 = __Mat3.Mat3;

import __Mat4 = require("./Mat4")
export import Mat4 = __Mat4.Mat4;

import __Quat = require("./Quat")
export import Quat = __Quat.Quat;

import __Transform = require("./Transform")
export import Transform = __Transform.Transform;

import __Color = require("./Color")
export import Color = __Color.Color;

import __Time = require("./Time")
export import Time = __Time.Time;

import __Angle = require("./Angle")
export import Angle = __Angle.Angle;

import Enum = require("./AllEnums")
import Flags = require("./AllFlags")

)";

  GenerateAllComponentsCode(sFileContent);

  ezFileWriter file;
  if (file.Open(szFile).Failed())
  {
    ezLog::Error("Failed to open file '{}'", szFile);
    return;
  }

  file.WriteBytes(sFileContent.GetData(), sFileContent.GetElementCount());
}

void ezTypeScriptBinding::InjectComponentImportExport(const char* szFile, const char* szComponentFile)
{
  ezSet<const ezRTTI*> found;
  ezDynamicArray<const ezRTTI*> sorted;
  sorted.Reserve(100);

  for (auto pRtti = ezRTTI::GetFirstInstance(); pRtti != nullptr; pRtti = pRtti->GetNextInstance())
  {
    CreateComponentTypeList(found, sorted, pRtti);
  }

  ezStringBuilder sImportExport, sTypeName;

  sImportExport.Format(R"(import __AllComponents = require("{}")
)",
    szComponentFile);

  for (const ezRTTI* pRtti : sorted)
  {
    GetTsName(pRtti, sTypeName);
    sImportExport.AppendFormat("export import {0} = __AllComponents.{0};\n",
      sTypeName);
  }

  AppendToTextFile(szFile, sImportExport);
}
