[PLATFORMS]
ALL

[PERMUTATIONS]

BLEND_MODE
RENDER_PASS
TOPOLOGY
VERTEX_SKINNING
TWO_SIDED = FALSE
FLIP_WINDING = FALSE
SHADING_MODE = SHADING_MODE_FULLBRIGHT
SHADING_QUALITY = SHADING_QUALITY_NORMAL
CAMERA_MODE = CAMERA_MODE_PERSPECTIVE

[RENDERSTATE]

#include <Shaders/Materials/MaterialState.h>

WireFrame = true

[VERTEXSHADER]

#if VERTEX_SKINNING
    #define USE_SKINNING
#endif

#include <Shaders/Materials/DefaultMaterialCB.h>
#include <Shaders/Materials/MaterialVertexShader.h>

VS_OUT main(VS_IN Input)
{
  return FillVertexData(Input);
}

[GEOMETRYSHADER]

#if TOPOLOGY == TOPOLOGY_TRIANGLES

struct GS_IN
{
  float4 Position : SV_Position;
  float3 WorldPos : WORLDPOS;
  uint InstanceID : SV_InstanceID;
};

struct GS_OUT
{
  float4 Position : SV_Position;
  float3 WorldPos : WORLDPOS;
  float3 Normal : NORMAL;
  float3 Barycentric : TEXCOORD0;
  uint InstanceID : SV_InstanceID;
};

[maxvertexcount(3)]
void main( triangle GS_IN input[3], inout TriangleStream<GS_OUT> outputStream )
{
  float3 edge1 = input[1].WorldPos - input[0].WorldPos;
  float3 edge2 = input[2].WorldPos - input[0].WorldPos;
  float3 normal = normalize(cross(edge1, edge2));

  GS_OUT output;

  for (uint i = 0; i < 3; ++i)
  {
    output.Position = input[i].Position;
    output.WorldPos = input[i].WorldPos;
    output.Normal = normal;
    output.Barycentric = float3(i==0, i==1, i==2);
    output.InstanceID = input[i].InstanceID;

    outputStream.Append(output);
  }

  outputStream.RestartStrip();
}

#endif

[PIXELSHADER]

#if TOPOLOGY == TOPOLOGY_TRIANGLES
  #define USE_NORMAL
#endif

#define CUSTOM_INTERPOLATOR float3 Barycentric : TEXCOORD0;

#include <Shaders/Materials/DefaultMaterialCB.h>
#include <Shaders/Materials/MaterialPixelShader.h>

Texture2D BaseTexture;
SamplerState BaseTexture_AutoSampler;

float3 GetNormal(PS_IN Input)
{
  #if TOPOLOGY == TOPOLOGY_TRIANGLES
    return Input.Normal;
  #else
    return float3(0.0f, 0.0f, 1.0f);
  #endif
}

float3 GetDiffuseColor(PS_IN Input)
{
  return float3(0.1, 0.7, 0.1);
}

float3 GetSpecularColor(PS_IN Input)
{
  return 0.04f;
}

float GetRoughness(PS_IN Input)
{
  return 1.0f;
}

float GetOpacity(PS_IN Input)
{
  return 1.0f;
}
