[PLATFORMS]
ALL

[PERMUTATIONS]

BLEND_MODE
RENDER_PASS
TWO_SIDED = TRUE
SHADING_MODE = SHADING_MODE_FULLBRIGHT
CAMERA_MODE
SHADING_QUALITY
VERTEX_SHADER_RENDER_TARGET_ARRAY_INDEX

[MATERIALPARAMETER]

Permutation BLEND_MODE;

float3 SunDir @Default(float3(1.0f, 0.0f, 0.0f));

Texture3D NoiseMap;

[RENDERSTATE]

#include <Shaders/Materials/MaterialState.h>

DepthWrite = false

[SHADER]

#include <Shaders/Common/GlobalConstants.h>

CONSTANT_BUFFER(ezMaterialConstants, 1)
{
  FLOAT3(SunDir);
};

[VERTEXSHADER]

#define CUSTOM_INTERPOLATOR float3 ViewDirection : TEXCOORD0; float3 CameraPos : TEXCOORD1;

#include <Shaders/Materials/MaterialVertexShader.h>

VS_OUT main(VS_IN Input)
{
  VS_OUT Output = FillVertexData(Input);
  
  float2 ScreenPos = sign(Input.Position.xy);
  float4 dir = mul(GetScreenToCameraMatrix(), float4(ScreenPos.xy,1.0,1.0));
  dir.w = 0.0;
    
  ezPerInstanceData data = GetInstanceData();
  float4x4 objectToWorld = TransformToMatrix(data.ObjectToWorld);

  Output.Position = float4(ScreenPos.xy, 1.0, 1.0);
  Output.ViewDirection = mul(GetCameraToWorldMatrix(), dir).xyz;
  
  Output.CameraPos = mul(GetCameraToWorldMatrix(), float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

  return Output;
}

[GEOMETRYSHADER]

#define CUSTOM_INTERPOLATOR float3 ViewDirection : TEXCOORD0; float3 CameraPos : TEXCOORD1;

void CopyCustomInterpolators(GS_OUT output, VS_OUT input)
{
  output.ViewDirection = input.ViewDirection;
  output.CameraPos = input.CameraPos;
}

#include <Shaders/Materials/MaterialStereoGeometryShader.h>

[PIXELSHADER]

Texture3D NoiseMap;
SamplerState NoiseMap_AutoSampler;

#define CUSTOM_INTERPOLATOR float3 ViewDirection : TEXCOORD0; float3 CameraPos : TEXCOORD1;

#include <Shaders/Materials/MaterialPixelShader.h>
#include <Shaders/Materials/CloudHelpers.h>

float LightRay(float3 start, float3 dir)
{
  float stepL = 0.1f;
  float density = 0.0;
  for(int i=0; i < 20; i++)
  {
    start += dir * stepL;
    float weatherData = GetWeatherData(start.xy);
    density += SampleCloudDensity(start, weatherData);    
  }
  return density;
}

float4 TraceClouds()
{
  float3 offset_over_sealevel = float3(0.0, 0.0, 300.0);

  float3 camera_position = float3(0.0, 0.0, PLANET_RADIUS) + offset_over_sealevel;
  
  float3 viewDir = normalize(G.Input.ViewDirection);
  
#ifndef SINGLE_CLOUD
  if(viewDir.z < 0.1f)
  {
    return float4(0.0f, 0.0f, 0.0f, 0.0f);
  }
#endif
  
  float2 cloudStartDistance = ray_sphere_intersect(camera_position, viewDir, PLANET_RADIUS + CLOUD_START);
  
#ifdef SINGLE_CLOUD
  float3 curSamplePoint = G.Input.CameraPos + viewDir * 2.0f;
  float stepSize = 0.2f;
#else
  float3 curSamplePoint = offset_over_sealevel + viewDir * cloudStartDistance.y;
  float stepSize = 2.0f;
#endif
  
  
  

  
  float density = 0.0;
  
  float3 color = float3(0.0f, 0.0f, 0.0f);
  
  for(int i=0; i < 64; i++)
  {
    float weatherData = GetWeatherData(curSamplePoint.xy);
    float curDensity = SampleCloudDensity(curSamplePoint, weatherData);
    curSamplePoint += viewDir * stepSize;
	
	if(curDensity > 0.0f)
	{
		density += curDensity;
		
		float densityOnLightRay = LightRay(curSamplePoint, SunDir);
		
		color += float3(1.0f, 1.0f, 1.0f) * exp(-densityOnLightRay) * exp(-density) * 0.5;
	}
  }
  
  density = 1.0f - exp(-density);
  
  return float4(color, saturate(density));
}


float3 GetNormal()
{
  return float3(0.0f, 0.0f, 1.0f);
}

float3 GetDiffuseColor()
{
	float4 clouds = TraceClouds();
    return clouds.rgb;
}

float3 GetSpecularColor()
{
  return 0.0f;
}

float GetRoughness()
{
  return 1.0f;
}

float GetOpacity()
{
  return TraceClouds().a;
}
