[PLATFORMS]
ALL

[PERMUTATIONS]

BLEND_MODE
RENDER_PASS
TOPOLOGY
TWO_SIDED = FALSE
FLIP_WINDING = FALSE
SHADING_MODE = SHADING_MODE_FULLBRIGHT
SHADING_QUALITY = SHADING_QUALITY_NORMAL
CAMERA_MODE = CAMERA_MODE_PERSPECTIVE

[RENDERSTATE]

#include <Shaders/Materials/MaterialState.h>

[VERTEXSHADER]

#include <Shaders/Materials/DefaultMaterialCB.h>
#include <Shaders/Materials/MaterialVertexShader.h>

VS_OUT main(VS_IN Input)
{
  return FillVertexData(Input);
}

[GEOMETRYSHADER]

#if TOPOLOGY == TOPOLOGY_TRIANGLES

struct GS_IN
{
  float4 Position : SV_Position;
  float3 WorldPos : WORLDPOS;
  uint InstanceID : SV_InstanceID;
};

struct GS_OUT
{
  float4 Position : SV_Position;
  float3 WorldPos : WORLDPOS;
  float3 Normal : NORMAL;
  float3 Barycentric : TEXCOORD0;
  uint InstanceID : SV_InstanceID;
};

[maxvertexcount(3)]
void main( triangle GS_IN input[3], inout TriangleStream<GS_OUT> outputStream )
{
  float3 edge1 = input[1].WorldPos - input[0].WorldPos;
  float3 edge2 = input[2].WorldPos - input[0].WorldPos;
  float3 normal = normalize(cross(edge1, edge2));

  GS_OUT output;

  for (uint i = 0; i < 3; ++i)
  {
    output.Position = input[i].Position;
    output.WorldPos = input[i].WorldPos;
    output.Normal = normal;
    output.Barycentric = float3(i==0, i==1, i==2);
    output.InstanceID = input[i].InstanceID;

    outputStream.Append(output);
  }

  outputStream.RestartStrip();
}

#endif

[PIXELSHADER]

#if TOPOLOGY == TOPOLOGY_TRIANGLES
  #define USE_NORMAL
#endif

#define CUSTOM_INTERPOLATOR float3 Barycentric : TEXCOORD0;

#include <Shaders/Materials/DefaultMaterialCB.h>
#include <Shaders/Materials/MaterialPixelShader.h>

Texture2D BaseTexture;
SamplerState BaseTexture_AutoSampler;

float edgeFactor()
{
  float3 d = fwidth(G.Input.Barycentric);
  float3 a3 = smoothstep(float3(0.0, 0.0, 0.0), d, G.Input.Barycentric);
  return min(min(a3.x, a3.y), a3.z);
}

float3 GetNormal()
{
  #if TOPOLOGY == TOPOLOGY_TRIANGLES
    return G.Input.Normal;
  #else
    return float3(0.0f, 0.0f, 1.0f);
  #endif
}

float3 GetDiffuseColor()
{
  float3 color = lerp(0.2, 0.5, edgeFactor());

  float light = clamp(dot(G.Input.Normal.xyz, normalize(float3(1, 0.5, 2))), 0.2, 0.9);
  return color * light;
}

float3 GetSpecularColor()
{
  return 0.04f;
}

float GetRoughness()
{
  return 1.0f;
}

float GetOpacity()
{
  return 1.0f;
}
