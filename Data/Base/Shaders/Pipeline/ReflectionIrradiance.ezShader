[PLATFORMS]
ALL

[PERMUTATIONS]

[COMPUTESHADER]

#include <Shaders/Common/AmbientCubeBasis.h>
#include "ReflectionIrradianceConstants.h"

float3 FibonacciSphere(int sampleIndex, int numSamples)
{
  float offset = 2.0f / numSamples;
  float increment = PI * (3.0f - sqrt(5.0f));

  float y = ((sampleIndex * offset) - 1) + (offset / 2);
  float r = sqrt(1 - y*y);

  float phi = ((sampleIndex + 1) % numSamples) * increment;

  float x = cos(phi) * r;
  float z = sin(phi) * r;

  return float3(x, y, z);
}

#define NUM_THREADS 64

TextureCube InputCubemap;
RWTexture2D<float4> IrradianceOutput;

groupshared AmbientCubeFloat3 SharedACs[NUM_THREADS];

[numthreads(NUM_THREADS, 1, 1)]
void main(uint DispatchId : SV_DispatchThreadID)
{
  float3 dir = FibonacciSphere(DispatchId, NUM_THREADS);
  
  float3 inputColor = InputCubemap.SampleLevel(LinearSampler, dir, LodLevel).rgb;
  float weight = (4.0f * PI) / NUM_THREADS;
  
  AmbientCubeFloat3 localAC;
  FillAmbientCubeFromSample(localAC, inputColor, dir, weight);
  
  SharedACs[DispatchId] = localAC;  
  
  GroupMemoryBarrierWithGroupSync();
  
  if (DispatchId == 0)
  {
    for (uint threadIndex = 1; threadIndex < NUM_THREADS; ++threadIndex)
    {
      AddAmbientCube(localAC, SharedACs[threadIndex]);
    }
    
    // Apply intensity, saturation and write out
    for (uint i = 0; i < AMBIENT_CUBE_NUM_DIRS; ++i)
    {
      float3 color = localAC.m_Values[i];
      float luminance = GetLuminance(color);
      color = lerp(luminance, color, Saturation) * Intensity;
      
      IrradianceOutput[uint2(i, 0)] = float4(color, 1);
    }
  }
}
